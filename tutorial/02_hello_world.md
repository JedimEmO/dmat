# Our first UI

It's time to go through the basics of making a simple gui application using DOMINATOR!
Let's briefly go over the project setup, and then we'll get started.

## Project setup

A dominator project is a rust project that compiles to wasm.
This means we can use a fairly recognisable rust project structure.

To build the application for the browser, there are a few options available.
Throughout this tutorial, we will use `rollup` with the `@wasm-tool/rollup-plugin-rust`.

We will not cover the details of setting up a project with rollup here, but you can take a look at the `tutorial/examples/hello-world` project for a simple example.
Feel free to modify the `rollup.config.js` file to suit your needs.

In the dist folder, we have the `index.html` file.
It is the entrypoint for our application, and it includes the js bootstrap file that will be generated by rollup.
This js file will set up the memory for and load the wasm module, and take care of any bindings we may need between v8 and the wasm world.

## The code

We start out with a very simple, yet obligatory, hello world example:

```rust
use dominator::{append_dom, body, html};
use wasm_bindgen::prelude::*;

#[wasm_bindgen(start)]
fn main() {
    append_dom(&body(), html!("h1", {
       .text("Hello, world!")
   }));
}
```

Although simple, there are a lot of things to unpack here!

The main function is annotated with `#[wasm_bindgen(start)]`.
This instructs wasm_bindgen to generate code such that the function will be called when the wasm module is loaded, much like the main function in a binary crate.

The `append_dom` function from dominator lets us attach a dom node we create from rust to the dom tree to an existing DOM node.
In this case, we use the `body` utility function, which effectively lets us add our node to the `<body>` node in our html file.

The `html!` macro from dominator will be our main tool for constructing dom HTML nodes.
The first parameter is the tag name to construct.

The second parameter is a list of chained method calls that will be applied to the `DomBuilder<HtmlElement>` instance used to construct the node.
Don't worry about understanding all the details of this.
For now, be content to know that calling `.text()` within the block we pass to the macro will create a text node with the provided static text content!

## The basic of FRP

Now that we have made a simple static html node, we'll soon want to make it a bit more dynamic.
But before we dive into the code, we'll very briefly go over the fundamental principle of functional reactive programming.

The most important principle to understand is that in FRP, we consider the view to be a functional mapping of the state.
Secondly, we consider the state to be a stream of values, not just a single value held in memory.

What does this mean?

Imagine that you have a variable `x` that holds the value `5`, and we want to turn it into the text `"5"`.

One way of doing this, of course, is to simply call `x.to_string()`.
This gives us the string representation of `x` at the time of the call.
This, however, is not very useful if we want to keep the text up to date with the value of `x`.
If we reassign a new value to x, the string representation will remain the same old `"5"` as it was before.

Imagine now that instead of `x` holding the single value `5`, it is a stream of i32 values.
We can then map this stream to a stream of strings by calling `x.map(|x| x.to_string())`.
This gives us a new stream, which will yield the string representation of the latest value of `x` whenever `x` yields a new value.

This is the basic idea of FRP. 
We can combine these functional mappings over streams of state to create a dynamic view, that will always represent the latest state!

This is where `futures_signals` comes in.
It provides us with the tools needed to represent both the state and the sequence of changes to it in the form of signals!

For our first simple examples, we will be using the `Mutable<T>` type from `futures_signals`.
You can think of this as a storage box that holds your value of type T.
But additionally, you can create a signal from it that will yield the latest value inside the box whenever it is changed.

To recreate our `x` example from before, we can do the following:

```rust
let x = Mutable::new(5);
let x_string = x.signal().map(|x| x.to_string());
x.set(6);
```

A very important thing to be aware of is that the signal will only yield the latest value when it is polled.
Signals work like futures, and if you do not poll them, they do absolutely nothing!

Luckily for us, in the majority of cases, DOMINATOR will take care of this for us.
It typically has a `_signal` or `_signal_vec` (more about vecs and maps later) alternatives to its normal methods, to which you can pass the corresponding signal.

For instance, if we wanted to create a span that always represents the latest value of `x`, we could do the following:

```rust
fn span_with_x(x: Mutable<i32>) -> Dom {
    let x_string_signal = x.signal().map(|x| x.to_string());
    html!("span", {
        .text_signal(x_string_signal)
    })
}
```

This span will now always display the latest value seen from the `x_string_signal` without us having to do anything else!

### Manually polling

Sometimes, however, we may want to manually poll a signal.
There are several ways to do this, but the easiest and most straight forward way is to use `for_each()` inside of a future:

```rust
let x = Mutable::new(0);
let x_sig = x.signal();
html!("span", {
    .future(async move {
        x_sig.for_each(|v| debug!("x is: {}", x)).await;
        async {}
    })
});
```

This will poll the x signal and log new values as long as the DOM node is alive.

### More in depth on signals

We barely scratched the introductory surface to signals and FRP in this section.
I recommend jumping over to Pauan's [great tutorial on futures signals](https://docs.rs/futures-signals/latest/futures_signals/tutorial/index.html)
to learn more about the details of how signals work, and how to use them.


## Dynamic view with futures signals FRP

We can put this knowledge to use to create a dynamic view of our hello world example.
Let's make a button that, when clicked, changes the text displayed in the header:

```rust
use dominator::{append_dom, body, clone, events, html};
use futures_signals::signal::Mutable;
use wasm_bindgen::prelude::*;

#[wasm_bindgen(start)]
fn main() {
    let our_text_string = Mutable::new("Hello, world!".to_string());

    append_dom(&body(), html!("div", {
        .child(html!("h1", {
            .text_signal(our_text_string.signal_cloned())
        }))
        .child(html!("button", {
            .text("Click me!")
            .event(clone!(our_text_string => move |_: events::Click| {
                our_text_string.set("You clicked!".to_string());
            }))
        }))
    }));
}
```

There are some new concepts here.
First, let's look at the `clone!` macro.

This is a quality of life macro provided by dominator, which lets us clone and capture a set of variables into a closure.
Without it, we would have to write something like this:

```rust
let our_text_string = Mutable::new("Hello, world!".to_string());
let our_text_string_cloned = our_text_string.clone();

html!("button", {
    .text("Click me!")
    .event(move |_: events::Click| {
        our_text_string_cloned.set("You clicked!".to_string());
    })
});
```

We also now see that the `.event()` method allows us to register an event handler on our dom nodes.
It's important to be aware that the callback we give to the event handler must be `'static`, meaning it can only capture our state by value, or by a leaked static reference to it.
References to any other lifetime is not allowed, as we cannot guarantee that the reference will be valid when the event is fired.

In this case, we are registering a handler for the `Click` event, which will set the text to a new value.

Also notice that there is no explicit updating of the dom happening in our code here.
The only thing we do is mutate the base state, and the `text_signal` will take care of updating the dom for us.

----
Previous: [Introduction](./01_introduction.md) Next: [Lightweight DMAT](./03_lightweight_dmat.md)
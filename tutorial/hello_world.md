# Our first UI

It's time to go through the basics of making a simple gui application.
Let's briefly go over the project setup, and then we'll get started.

## Project setup

Each UI application is a separate crate, and as such, has a Cargo.toml file where it specifies its dependencies.

For the `hello_world` example, we will need the `dominator` and `wasm-bindgen` crates.

We also have a few files related to the rollup bundler and the npm package to track the build dependencies.
We use it with the `@wasm-tool/rollup-plugin-rust` plugin.

In the dist folder, we have the `index.html` file.
It is the entrypoint for our application, and it includes the js bootstrap file that will be generated by rollup.
This js file will set up the memory for and load the wasm module, and take care of any bindings we may need between v8 and the wasm world.


## The code

The `hello_world` example is a very simple application that just displays a header with some text.
It is all contained in the `src/lib.rs` file.

Note that the main file is annotated with `#[wasm_bindgen(start)]`.
This is how we communicate that the main function should run when the wasm module is loaded.
Note that the `main` name is arbitrary; it is chosen for convention, but could be any legal name.

```rust
use dominator::{append_dom, body, html};
use wasm_bindgen::prelude::*;

#[wasm_bindgen(start)]
fn main() {
    append_dom(&body(), html!("h1", {
       .text("Hello, world!")
   }));
}
```

The `append_dom` function from dominator lets us attach a dom node we construct from rust to the dom tree.
In this case, we use the `body` utility function, which effectively lets us add our node to the `<body>` node in our html file.

The `html!` macro from dominator will be our main tool for constructing dom nodes.
The first parameter is the tag name to construct.

The second parameter is a list of chained method calls that will be applied to the `DomBuilder<HtmlElement>` instance used to construct the node.
Don't worry about understanding all the details of this; for now, be content to know that calling `.text()` within the block we pass to the macro will create a text node with the provided static text content, and append it to the dom element we created!

## Adding some dynamic content

Now that we have made a simple static page, let's make it render some dynamic content with a little bit of state.

When doing FRP using futures_signals, we will typically think about the state as an observable base.
We can then calculate what the DOM should be based on the state.

We call this resulting DOM a *derivation* of the state.

But that's enough theory for now, let's make our state.
We can use a nice type called `Mutable`. 
This can hold any value we want, and we can create a signal from it which the view can use to derive the DOM.

Let's modify our main function:

```rust
use dominator::{append_dom, body, html};
use futures_signals::signal::Mutable;
use wasm_bindgen::prelude::*;

#[wasm_bindgen(start)]
fn main() {
    let our_text_string = Mutable::new("Hello, world!".to_string());
    
    append_dom(&body(), html!("h1", {
       .text_signal(our_text_string.signal_cloned())
   }));
}
```

Observe that we changed the `text` method to `text_signal`. 
This lets us declare that the text content will not be a static value, but rather the latest value that the signal yields.
It's useful to think of signals as a stream of values, where we can get the latest value at any time.

Now, this is not very different from our previous example, let's make it a bit more interesting.

We can add a button that will change the text when clicked.

```rust
use dominator::{append_dom, body, clone, events, html};
use futures_signals::signal::Mutable;
use wasm_bindgen::prelude::*;

#[wasm_bindgen(start)]
fn main() {
    let our_text_string = Mutable::new("Hello, world!".to_string());

    append_dom(&body(), html!("div", {
        .child(html!("h1", {
            .text_signal(our_text_string.signal_cloned())
        }))
        .child(html!("button", {
            .text("Click me!")
            .event(clone!(our_text_string => move |_: events::Click| {
                our_text_string.set("You clicked!".to_string());
            }))
        }))
    }));
}
```

There are some new concepts here.
First, let's look at the `clone!` macro.

This is a quality of life macro provided by dominator, which lets us clone and capture a set of variables into a closure.
Without it, we would have to write something like this:

```rust
let our_text_string = Mutable::new("Hello, world!".to_string());
let our_text_string_cloned = our_text_string.clone();

html!("button", {
    .text("Click me!")
    .event(move |_: events::Click| {
        our_text_string_cloned.set("You clicked!".to_string());
    })
});
```

We also now see that the `.event()` method allows us to register an event handler on our dom nodes.
It's important to be aware that the callback we give to the event handler must be `'static`, meaning it can only capture our state by value, or by a leaked static reference to it.
References to any other lifetime is not allowed, as we cannot guarantee that the reference will be valid when the event is fired.

In this case, we are registering a handler for the `Click` event, which will set the text to a new value.

Also notice that there is no explicit updating of the dom happening in our code here.
The only thing we do is mutate the base state, and the text_signal will take care of updating the dom for us.

Previous: [Introduction](./introduction.md)